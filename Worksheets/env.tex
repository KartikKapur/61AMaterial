\documentclass{article}
\usepackage{work}\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{automata, positioning}  
\usepackage{amsmath}
\def\title{Environments}
\lstset{ 
numbers = left,
  stepnumber=1,
  firstnumber = 1,
  numberfirstline = true,
  showstringspaces=false,
  language = Python 
  }
\begin{document}
\maketitle
\section{Introduction}
This worksheet will serve as a brief review of everything that has occurred in CS61A over the last few weeks. 
\subsection{Functions}
\textbf{Functions}, in the most basic sense, are a block of code, that can be used to perform some type of action. Functions have multiple uses, and can be used as return values, nested definitions, and arguments. \\* \bigskip

\subsubsection{Structure}
\begin{lstlisting}[language = Python]
def hello(hi):
     ...
     return bye
\end{lstlisting}
In the above function, "hello" is the function name, hi is the argument and bye is the return value. \\*
\bigskip
Now that we've gone over the basics of functions, let's describe all of their use cases. \\*
\subsubsection{Functions as arguments}
Functions can be used as arguments. Let's take the following example: \\*
\bigskip
\begin{lstlisting}[language = Python]
def eatFood(makeFood):
     makeFood()
     print("I have eaten!")
\end{lstlisting}
Here we have a function \emph{eatFood}. In this, we have an argument, \emph{makeFood}. We call the function \emph{makeFood} and then say that we have eaten. Depending on the food that we want to eat, we will have a different method to make it. However, regardless of how we make the food, we will eat it the same way, with our mouths! So instead of making a new function for eating every type of food, we have a function for eating that takes in a function that makes our food, allowing us to make a more universal function. 
\subsubsection{Returning Functions}
Say we wanted to make a function that allows us to eat cook some food given 1 ingredient and a set amount of time. At runtime, our function would take in a "mystery ingredient" and we would compare all the foods 
\begin{lstlisting}[language = Python]
func1 = makeFood(ravioli, x, 2)
func2 = makeFood(ice cream, x, 12)
func3 = makeFood(jam, x, 19)
\end{lstlisting}
You can see why this can get a bit tiring, so instead of doing this, we can have return a function. For the above example, we can make a function that takes in 3 arguments, the 2 food items, and the amount of time you want it to cook so that it looks as follows: 
\begin{lstlisting}[language = Python]
def checkFood(food1, food2, time):
     return makeFood(food1, food2, time)
\end{lstlisting}
\Question{Butter Nutter}
\begin{subq}
 \subqs Label the parts of the following function: 
 \lstinputlisting[language=Python, firstline=1, lastline=11]{../code/environments.py}
  \bigskip
 
\begin{solution}

\lstinputlisting[language=Python, firstline=15, lastline=23]{../code/environments.py}
 \end{solution}
 \subqs What does the above code snippit return? 
 \begin{solution}
 strawberrycrunchy
 \end{solution}
\end{subq}
\newpage



\end{document}